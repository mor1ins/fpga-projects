//===========================================================================
// Filename: dphy_rx_tb.v
// Copyright(c) 2017 Lattice Semiconductor Corporation. All rights reserved. 
//===========================================================================
//===========================================================================
// Verilog file generated by Clarity Designer    09/28/2020    22:56:10  
// Filename  : csi2_dphy_tb.v                                                
// IP package: CSI-2/DSI D-PHY Receiver 1.4                           
// Copyright(c) 2016 Lattice Semiconductor Corporation. All rights reserved. 
//===========================================================================
`timescale 1 ps / 1 ps

`include "csi2_model.v"
`include "dsi_model.v"
`include "tb_setup_params.v"

module tb(); 
  `include "dut_params.v"
  // Design parameters
  parameter integer dphy_clk_period = 1000000/(BYTECLK_MHZ*RX_GEAR/2); //in ps, clock period of DPHY.

  // Testbench parameters for video data
  parameter num_frames = `NUM_FRAMES; // number of frames
  parameter num_lines = `NUM_LINES; //number of video lines
  parameter SOT_DRIVE_EDGE = `SOT_DRIVE_EDGE;
  
//////////////////////////////////////////////////////////////////////////////////
/// • Intermotion Technology
/// • DPHY Rx Changes
/// • Date June 2, 2019
/// • Davit Tamazyan
/// • Added NULL_PACKET in TB.
//////////////////////////////////////////////////////////////////////////////////
  parameter NULL_PACKET    = `NULL_PACKET;
  parameter csi2_num_pixels = `CSI2_NUM_PIXELS;
  parameter init_delay = `INIT_DELAY;
  parameter TEST_DATA_TYPE = `TEST_DATA_TYPE;
  parameter VIDEO_DATA_TYPE = (RX_TYPE == "DSI")?
                                                  (TEST_DATA_TYPE ==    "RGB666_LOOSE")? 6'h2E :
                                                  (TEST_DATA_TYPE ==          "RGB666")? 6'h1E :
                                                                            /*"RGB888"*/ 6'h1E
                                                  :
                                                  (TEST_DATA_TYPE ==            "RAW8")? 6'h2A :
                                                  (TEST_DATA_TYPE ==           "RAW10")? 6'h2B :
                                                  (TEST_DATA_TYPE ==           "RAW12")? 6'h2C :
                                                  (TEST_DATA_TYPE ==       "YUV420_10")? 6'h19 :
                                                  (TEST_DATA_TYPE ==        "YUV420_8")? 6'h18 :
                                                  (TEST_DATA_TYPE ==       "YUV422_10")? 6'h1F :
                                                  (TEST_DATA_TYPE ==        "YUV422_8")? 6'h1E :
                                                  (TEST_DATA_TYPE == "LEGACY_YUV420_8")? 6'h1A :
                                                  (TEST_DATA_TYPE ==  "YUV420_10_CSPS")? 6'h1D :
                                                  (TEST_DATA_TYPE ==   "YUV420_8_CSPS")? 6'h1C :
                                                                            /*"RGB888"*/ 6'h24;
  parameter t_lpx = `DPHY_LPX;
  parameter t_clk_prepare = `DPHY_CLK_PREPARE; //in ps, set between 38 to 95 ns
  parameter t_clk_zero = `DPHY_CLK_ZERO; //in ps, (clk_prepare + clk_zero minimum should be 300ns)
  parameter t_clk_pre = 12*(dphy_clk_period/2); // in ps
  parameter t_clk_post = (60000 + (52*dphy_clk_period/2)); // in ps, minimum of 60ns+52*UI
  parameter t_clk_trail = `DPHY_CLK_TRAIL; //in ps, minimum of 60ns
  parameter t_hs_prepare = (100000 + (4*dphy_clk_period/2)); //in ps, set between 40ns+4*UI to max of 85ns+6*UI
  parameter t_hs_zero = ((200000 + (10*dphy_clk_period/2)) - t_hs_prepare); //in ps, hs_prepare + hs_zero minimum should be 145ns+10*UI
  parameter t_hs_trail = ((60000 + (4*dphy_clk_period/2)) + (105000 + (12*dphy_clk_period/2)))/2; //in ps, minimum should be 60ns+4*UI, max should be 105ns+12*UI


  parameter vact_payload = `DSI_VACT_PAYLOAD; //VACT 2-byte word count (total number of bytes of active pixels in 1 line)
  parameter hsa_payload = `DSI_HSA_PAYLOAD; //HSA 2-byte word count (number of bytes of payload, see MIPI DSI spec v1.1 figure 30), used for Non-burst sync pulse
  parameter bllp_payload = `DSI_BLLP_PAYLOAD; //BLLP 2-byte word count (number of bytes of payload, see MIPI DSI spec v1.1 figure 30), used for HS_ONLY mode
  parameter hbp_payload = `DSI_HBP_PAYLOAD; //HBP 2-byte word count (number of bytes of payload, see MIPI DSI spec v1.1 figure 30), used for HS_ONLY mode and HS_LP Non-burst sync pulse
  parameter hfp_payload = `DSI_HFP_PAYLOAD; //HFP 2-byte word count (number of bytes of payload, see MIPI DSI spec v1.1 figure 30), used for HS_ONLY mode and HS_LP Non-burst sync pulse
  parameter lps_bllp_duration = `DSI_LPS_BLLP_DURATION; // in ps, used for HS_LP mode, this pertains to the LP-11 state duration for blanking
  parameter lps_hbp_duration = `DSI_LPS_HBP_DURATION; // in ps, used for HS_LP Non-burst sync events and burst mode, this pertains to the LP-11 state duration for horizontal back porch
  parameter lps_hfp_duration = `DSI_LPS_HFP_DURATION; // in ps, used for HS_LP Non-burst sync events and burst mode, this pertains to the LP-11 state duration for horizontal front porch
  parameter virtual_channel = `VIRTUAL_CHANNEL; // virtual channel ID. example: 2'h0
  // parameter video_data_type = `VIDEO_DATA_TYPE; // video data type DI. example: 6'h3E = RGB888
  parameter vsa_lines = `DSI_VSA_LINES; // number of VSA lines, see MIPI DSI spec v1.1 figure 30
  parameter vbp_lines = `DSI_VBP_LINES; // number of VBP lines, see MIPI DSI spec v1.1 figure 30
  parameter vfp_lines = `DSI_VFP_LINES; // number of VFP lines, see MIPI DSI spec v1.1 figure 30
  parameter eotp_enable = `DSI_EOTP_ENABLE; // to enable/disable EOTP packet
  parameter debug_on = `DPHY_DEBUG_ON; // for enabling/disabling DPHY data debug messages
  parameter frame_gap = 5000000; //delay between frames (in ps)
  //CSI2 parameters
  parameter lps_gap = `CSI2_LPS_GAP;
  parameter ls_le_en = `CSI2_LS_LE_EN;

  localparam         num_pixels        = (RX_TYPE == "DSI")? (
                                                            32'd0
                                                           ) :
                                                           (
                                                             (TEST_DATA_TYPE == "RAW8")?            csi2_num_pixels        :
                                                             (TEST_DATA_TYPE == "RAW10")?           csi2_num_pixels * 5/4  :
                                                             (TEST_DATA_TYPE == "RAW12")?           csi2_num_pixels * 3/2  :
                                                             (TEST_DATA_TYPE == "YUV420_10")?       csi2_num_pixels * 5/4  : // odd line
                                                             (TEST_DATA_TYPE == "YUV420_8")?        csi2_num_pixels        : // odd line
                                                             (TEST_DATA_TYPE == "YUV422_10")?       csi2_num_pixels * 5/2  :
                                                             (TEST_DATA_TYPE == "YUV422_8")?        csi2_num_pixels * 2    :
                                                             (TEST_DATA_TYPE == "LEGACY_YUV420_8")? csi2_num_pixels * 3/2  :
                                                             (TEST_DATA_TYPE == "YUV420_10_CSPS")?  csi2_num_pixels * 5/4  : // odd line
                                                             (TEST_DATA_TYPE == "YUV420_8_CSPS")?   csi2_num_pixels        : // odd line
                                                           /*(TEST_DATA_TYPE == "RGB888")?*/        csi2_num_pixels * 3
                                                           );
  localparam         long_even_line_en = (RX_TYPE == "DSI")? (
                                                            32'd0
                                                           ) :
                                                           (
                                                             (TEST_DATA_TYPE == "RAW8")?            0 :
                                                             (TEST_DATA_TYPE == "RAW10")?           0 :
                                                             (TEST_DATA_TYPE == "RAW12")?           0 :
                                                             (TEST_DATA_TYPE == "YUV420_10")?       1 :
                                                             (TEST_DATA_TYPE == "YUV420_8")?        1 :
                                                             (TEST_DATA_TYPE == "YUV422_10")?       0 :
                                                             (TEST_DATA_TYPE == "YUV422_8")?        0 :
                                                             (TEST_DATA_TYPE == "LEGACY_YUV420_8")? 0 :
                                                             (TEST_DATA_TYPE == "YUV420_10_CSPS")?  1 :
                                                             (TEST_DATA_TYPE == "YUV420_8_CSPS")?   1 :
                                                           /*(TEST_DATA_TYPE == "RGB888")?*/        0
                                                           );

  parameter refclk_period = 1000000/BYTECLK_MHZ;

   real dphy_clk;
   reg cont_clk; //for csi2 model, HS_ONLY mode


//////////////////////////////////////////////////////////////////////////
/// Added checker
//////////////////////////////////////////////////////////////////////////
    /// Davit  
  reg eotb;
  integer wr_file; initial begin wr_file = $fopen("rx_crc_file.txt","w"); @(posedge eotb); $fclose(wr_file); end /// Davit
  reg [31:0] header               = 'd0;
  reg [15:0] data_cycle           = 'd0;
  reg [15:0] CRC                  = 'd0;
  reg [15:0] short_packet_count   = 'd0;
  reg [15:0] long_packet_count    = 'd0;
  reg [15:0] unknown_packet_count = 'd0;
  
  wire short_packet = (RX_TYPE == "CSI2")? |header[5:2] == 0 : header == 6'h1 | header == 6'h11 | header == 6'h21 | header == 6'h31;
  
  reg [RX_GEAR-1:0] lane0_byte_data;
  reg [RX_GEAR-1:0] lane1_byte_data;
  reg [RX_GEAR-1:0] lane2_byte_data;
  reg [RX_GEAR-1:0] lane3_byte_data;
  
  reg                    [15:0] reverse_crc  = 16'hFFFF;
  reg                    [15:0] crc          = 16'hFFFF;
  reg [RX_GEAR*NUM_RX_LANE-1:0] reverse_data = 'd0;
   
  generate
    if (PARSER == "OFF" && NUM_RX_LANE != 3) begin
       always begin
        //////////////////////////////////////////////////////
        /// Init
        //////////////////////////////////////////////////////
        while (!reset_n_i) begin
          #1000; /// 1ns
        end
        @(posedge capture_en_o); /// Data start
        @(posedge clk_byte_fr_i);
        @(posedge clk_byte_fr_i); /// Header start
        //////////////////////////////////////////////////////
        /// Read Header
        //////////////////////////////////////////////////////
        if (RX_GEAR == 16) begin
          if (NUM_RX_LANE == 4) begin
            header = {bd3_o[7:0],bd2_o[7:0],bd1_o[7:0],bd0_o[7:0]};
          end
          else if (NUM_RX_LANE == 2) begin
            header = {bd1_o[15:8],bd0_o[15:8],bd1_o[7:0],bd0_o[7:0]};
          end
          else if (NUM_RX_LANE == 1) begin
            header[15: 0] = {bd0_o[15:0]};
          @(posedge clk_byte_fr_i);
            header[31:16] = {bd0_o[15:0]};
          end
        end
        else if (RX_GEAR == 8) begin
          if (NUM_RX_LANE == 4) begin
            header = {bd3_o,bd2_o,bd1_o,bd0_o};
          end else
          if (NUM_RX_LANE == 3) begin
          end else
          if (NUM_RX_LANE == 2) begin
            header[15:0] = {bd1_o,bd0_o};
          @(posedge clk_byte_fr_i);
            header[31:16] = {bd1_o,bd0_o};
          end else
          if (NUM_RX_LANE == 1) begin
            header[7:0] = {bd0_o};
          @(posedge clk_byte_fr_i);
            header[15:8] = {bd0_o};
          @(posedge clk_byte_fr_i);
            header[23:16] = {bd0_o};
          @(posedge clk_byte_fr_i);
            header[31:24] = {bd0_o};
          end
        end
        #1;
        //////////////////////////////////////////////////////
        /// Check long or short packet
        //////////////////////////////////////////////////////
        if (short_packet) begin /// 6'd0 6'd1 6'd2 6'd3 F/L Start/End
          //////////////////////////////////////////////////////
          /// ***Short***
          //////////////////////////////////////////////////////
          short_packet_count = short_packet_count + 1;
        end
        else if (header[5:0] == VIDEO_DATA_TYPE) begin
          //////////////////////////////////////////////////////
          /// ***Long***
          //////////////////////////////////////////////////////
            long_packet_count = long_packet_count +1;
            //////////////////////////////////////////////////////
            /// Wait for CRC
            //////////////////////////////////////////////////////
            data_cycle  = (RX_GEAR == 16)? ((header[23:8] / (NUM_RX_LANE*2)) + 1)  : (header[23:8] / (NUM_RX_LANE) + 1);
            if (NUM_RX_LANE == 4 && RX_GEAR == 16) begin /// Workaround for now
              data_cycle  = data_cycle - 16'd1;
            end
            #1;
            while (|data_cycle) begin
              @(posedge clk_byte_fr_i);
              data_cycle = data_cycle - 1;
            end
            //////////////////////////////////////////////////////
            /// Read CRC
            //////////////////////////////////////////////////////
            if (RX_GEAR == 16) begin
              if (NUM_RX_LANE == 4) begin
                CRC = {bd1_o[15:8],bd0_o[15:8]}; $fwrite(wr_file,"%h\n",CRC);
              end
              else if (NUM_RX_LANE == 2) begin
                CRC = {bd1_o[7:0],bd0_o[7:0]}; $fwrite(wr_file,"%h\n",CRC);
              end
              else if (NUM_RX_LANE == 1) begin
                CRC = {bd0_o[15:0]}; $fwrite(wr_file,"%h\n",CRC);
              end
            end
            else begin
              if (NUM_RX_LANE == 4 | NUM_RX_LANE == 2) begin
                CRC = {bd1_o,bd0_o}; $fwrite(wr_file,"%h\n",CRC);
              end else
              if (NUM_RX_LANE == 1) begin
                CRC[7:0]  = {bd0_o}; 
                @(posedge clk_byte_fr_i);
                CRC[15:8] = {bd0_o}; $fwrite(wr_file,"%h\n",CRC);
              end
            end
        /*end*/
        end
        else begin
          //////////////////////////////////////////////////////
          /// ***Unknown***
          //////////////////////////////////////////////////////
          unknown_packet_count = unknown_packet_count + 1;
        end
      end
    end
    else if (PARSER == "ON")begin
       always begin
        //////////////////////////////////////////////////////
        /// Init
        //////////////////////////////////////////////////////
        reverse_crc = 16'hFFFF;
        crc         = 16'h0000;
        while (!reset_n_i) begin
          #1000; /// 1ns
        end
        @(posedge payload_en_o); /// Data start
        if (RX_GEAR == 8) begin
          //////////////////////////////////////////////////////
          /// Gear 8
          //////////////////////////////////////////////////////
          data_cycle = wc_o/NUM_RX_LANE;
          repeat (data_cycle) begin
            if (NUM_RX_LANE == 4) begin
              @(posedge clk_byte_fr_i);
              lane0_byte_data = payload_o[ 7: 0];
              lane1_byte_data = payload_o[15: 8];
              lane2_byte_data = payload_o[23:16];
              lane3_byte_data = payload_o[31:24];
              reverse_data    = {
                                      lane0_byte_data[0],lane0_byte_data[1],lane0_byte_data[2],lane0_byte_data[3],
                                      lane0_byte_data[4],lane0_byte_data[5],lane0_byte_data[6],lane0_byte_data[7],
                                      lane1_byte_data[0],lane1_byte_data[1],lane1_byte_data[2],lane1_byte_data[3],
                                      lane1_byte_data[4],lane1_byte_data[5],lane1_byte_data[6],lane1_byte_data[7],
                                      lane2_byte_data[0],lane2_byte_data[1],lane2_byte_data[2],lane2_byte_data[3],
                                      lane2_byte_data[4],lane2_byte_data[5],lane2_byte_data[6],lane2_byte_data[7],
                                      lane3_byte_data[0],lane3_byte_data[1],lane3_byte_data[2],lane3_byte_data[3],
                                      lane3_byte_data[4],lane3_byte_data[5],lane3_byte_data[6],lane3_byte_data[7]
                                    };
              reverse_crc     = nextCRC16_D32(reverse_data,reverse_crc);
            end else
            if (NUM_RX_LANE == 3) begin
              /// Coming soon
            end else
            if (NUM_RX_LANE == 2) begin
              @(posedge clk_byte_fr_i);
              lane0_byte_data = payload_o[ 7: 0];
              lane1_byte_data = payload_o[15: 8];
              reverse_data  = {
                                lane0_byte_data[0],lane0_byte_data[1],
                                lane0_byte_data[2],lane0_byte_data[3],
                                lane0_byte_data[4],lane0_byte_data[5],
                                lane0_byte_data[6],lane0_byte_data[7],
                                lane1_byte_data[0],lane1_byte_data[1],
                                lane1_byte_data[2],lane1_byte_data[3],
                                lane1_byte_data[4],lane1_byte_data[5],
                                lane1_byte_data[6],lane1_byte_data[7]
                              };
              reverse_crc     = nextCRC16_D16(reverse_data,reverse_crc);
              end else
            if (NUM_RX_LANE == 1) begin
              @(posedge clk_byte_fr_i);
              lane0_byte_data = payload_o[ 7: 0];
              reverse_data  = {
                                lane0_byte_data[0],
                                lane0_byte_data[1],
                                lane0_byte_data[2],
                                lane0_byte_data[3],
                                lane0_byte_data[4],
                                lane0_byte_data[5],
                                lane0_byte_data[6],
                                lane0_byte_data[7]
                              };
              reverse_crc   = nextCRC16_D8(reverse_data,reverse_crc);
            end
          end
          crc = {
                  reverse_crc[ 0],
                  reverse_crc[ 1],
                  reverse_crc[ 2],
                  reverse_crc[ 3],
                  reverse_crc[ 4],
                  reverse_crc[ 5],
                  reverse_crc[ 6],
                  reverse_crc[ 7],
                  reverse_crc[ 8],
                  reverse_crc[ 9],
                  reverse_crc[10],
                  reverse_crc[11],
                  reverse_crc[12],
                  reverse_crc[13],
                  reverse_crc[14],
                  reverse_crc[15]
                }; #1;
          $fwrite(wr_file,"%h\n",crc);
        end
        else begin
          //////////////////////////////////////////////////////
          /// Gear 16
          //////////////////////////////////////////////////////
          data_cycle = wc_o/(NUM_RX_LANE*2);
          repeat (data_cycle) begin
            if (NUM_RX_LANE == 4) begin
              @(posedge clk_byte_fr_i);
              lane0_byte_data = payload_o[15: 0];
              lane1_byte_data = payload_o[31:16];
              lane2_byte_data = payload_o[47:32];
              lane3_byte_data = payload_o[63:48];
              reverse_data    = {
                                      lane0_byte_data[ 0],lane0_byte_data[ 1],lane0_byte_data[ 2],lane0_byte_data[ 3],
                                      lane0_byte_data[ 4],lane0_byte_data[ 5],lane0_byte_data[ 6],lane0_byte_data[ 7],
                                      lane0_byte_data[ 8],lane0_byte_data[ 9],lane0_byte_data[10],lane0_byte_data[11],
                                      lane0_byte_data[12],lane0_byte_data[13],lane0_byte_data[14],lane0_byte_data[15],
                                      lane1_byte_data[ 0],lane1_byte_data[ 1],lane1_byte_data[ 2],lane1_byte_data[ 3],
                                      lane1_byte_data[ 4],lane1_byte_data[ 5],lane1_byte_data[ 6],lane1_byte_data[ 7],
                                      lane1_byte_data[ 8],lane1_byte_data[ 9],lane1_byte_data[10],lane1_byte_data[11],
                                      lane1_byte_data[12],lane1_byte_data[13],lane1_byte_data[14],lane1_byte_data[15],
                                      lane2_byte_data[ 0],lane2_byte_data[ 1],lane2_byte_data[ 2],lane2_byte_data[ 3],
                                      lane2_byte_data[ 4],lane2_byte_data[ 5],lane2_byte_data[ 6],lane2_byte_data[ 7],
                                      lane2_byte_data[ 8],lane2_byte_data[ 9],lane2_byte_data[10],lane2_byte_data[11],
                                      lane2_byte_data[12],lane2_byte_data[13],lane2_byte_data[14],lane2_byte_data[15],
                                      lane3_byte_data[ 0],lane3_byte_data[ 1],lane3_byte_data[ 2],lane3_byte_data[ 3],
                                      lane3_byte_data[ 4],lane3_byte_data[ 5],lane3_byte_data[ 6],lane3_byte_data[ 7],
                                      lane3_byte_data[ 8],lane3_byte_data[ 9],lane3_byte_data[10],lane3_byte_data[11],
                                      lane3_byte_data[12],lane3_byte_data[13],lane3_byte_data[14],lane3_byte_data[15]
                                    };
              reverse_crc     = nextCRC16_D64(reverse_data,reverse_crc);
            end else
            if (NUM_RX_LANE == 3) begin
            end else
            if (NUM_RX_LANE == 2) begin
              @(posedge clk_byte_fr_i);
              lane0_byte_data = payload_o[15: 0];
              lane1_byte_data = payload_o[31: 16];
              reverse_data    = {
                                      lane0_byte_data[ 0],lane0_byte_data[ 1],lane0_byte_data[ 2],lane0_byte_data[ 3],
                                      lane0_byte_data[ 4],lane0_byte_data[ 5],lane0_byte_data[ 6],lane0_byte_data[ 7],
                                      lane0_byte_data[ 8],lane0_byte_data[ 9],lane0_byte_data[10],lane0_byte_data[11],
                                      lane0_byte_data[12],lane0_byte_data[13],lane0_byte_data[14],lane0_byte_data[15],
                                      lane1_byte_data[ 0],lane1_byte_data[ 1],lane1_byte_data[ 2],lane1_byte_data[ 3],
                                      lane1_byte_data[ 4],lane1_byte_data[ 5],lane1_byte_data[ 6],lane1_byte_data[ 7],
                                      lane1_byte_data[ 8],lane1_byte_data[ 9],lane1_byte_data[10],lane1_byte_data[11],
                                      lane1_byte_data[12],lane1_byte_data[13],lane1_byte_data[14],lane1_byte_data[15]
                                    };
              reverse_crc     = nextCRC16_D32(reverse_data,reverse_crc);
            end else
            if (NUM_RX_LANE == 1) begin
                @(posedge clk_byte_fr_i);
                lane0_byte_data = payload_o[15: 0];
                reverse_data  = {
                                  lane0_byte_data[ 0],lane0_byte_data[1],
                                  lane0_byte_data[ 2],lane0_byte_data[3],
                                  lane0_byte_data[ 4],lane0_byte_data[5],
                                  lane0_byte_data[ 6],lane0_byte_data[7],
                                  lane0_byte_data[ 8],lane0_byte_data[9],
                                  lane0_byte_data[10],lane0_byte_data[11],
                                  lane0_byte_data[12],lane0_byte_data[13],
                                  lane0_byte_data[14],lane0_byte_data[15]
                                };
                reverse_crc     = nextCRC16_D16(reverse_data,reverse_crc);
            end
          end
          crc = {
                  reverse_crc[ 0],
                  reverse_crc[ 1],
                  reverse_crc[ 2],
                  reverse_crc[ 3],
                  reverse_crc[ 4],
                  reverse_crc[ 5],
                  reverse_crc[ 6],
                  reverse_crc[ 7],
                  reverse_crc[ 8],
                  reverse_crc[ 9],
                  reverse_crc[10],
                  reverse_crc[11],
                  reverse_crc[12],
                  reverse_crc[13],
                  reverse_crc[14],
                  reverse_crc[15]
                }; #1;
          $fwrite(wr_file,"%h\n",crc);
        end
      end
    end
  endgenerate
     
   /// End



   //DUT input ports
   reg resetn;
   wire clk_p_i;
   wire clk_n_i;
   wire d0_p_io;
   wire d0_n_io;
   wire d1_p_i;
   wire d1_n_i;
   wire d2_p_i;
   wire d2_n_i;
   wire d3_p_i;
   wire d3_n_i;
   reg refclk_i;


   wire clk_p_i_w;
   wire clk_n_i_w;
   wire d0_p_io_w;
   wire d0_n_io_w;
   wire d1_p_i_w;
   wire d1_n_i_w;
   wire d2_p_i_w;
   wire d2_n_i_w;
   wire d3_p_i_w;
   wire d3_n_i_w;

   // assign clk_p_i_w = clk_p_i;
   // assign clk_n_i_w = clk_n_i;
   /// NEW DUT ports
  wire                              clk_lp_ctrl_i;
  wire                              clk_byte_fr_i;

  wire                              reset_n_i;
  wire                              reset_lp_n_i;
  wire                              reset_byte_n_i;
  wire                              reset_byte_fr_n_i;

  wire                              pll_lock_i;
  
  wire pd_dphy_i                    = ~reset_n_i;


  // wire                              clk_p_i;
  // wire                              clk_n_i;
  // wire                              d0_p_io;
  // wire                              d0_n_io;
  // wire                              d0_p_i;
  // wire                              d0_n_i;
  // wire                              d1_p_i;
  // wire                              d1_n_i;
  // wire                              d2_p_i;
  // wire                              d2_n_i;
  // wire                              d3_p_i;
  // wire                              d3_n_i;

  wire                              lp_d0_tx_en_i;
  wire                              lp_d0_tx_p_i;
  wire                              lp_d0_tx_n_i;

  wire                              clk_byte_o;
  wire                              clk_byte_hs_o;

  wire                              lp_d0_rx_p_o;
  wire                              lp_d0_rx_n_o;
  wire                              lp_d1_rx_p_o;
  wire                              lp_d1_rx_n_o;
  wire                              lp_d2_rx_p_o;
  wire                              lp_d2_rx_n_o;
  wire                              lp_d3_rx_p_o;
  wire                              lp_d3_rx_n_o;
  wire                              cd_d0_o;

  wire [RX_GEAR-1:0]                bd0_o;
  wire [RX_GEAR-1:0]                bd1_o;
  wire [RX_GEAR-1:0]                bd2_o;
  wire [RX_GEAR-1:0]                bd3_o;
  wire                              capture_en_o;

  wire                              sp_en_o;
  wire                              lp_en_o;
  wire                              lp_av_en_o;
  wire [5:0]                        dt_o;
  wire [1:0]                        vc_o;
  wire [15:0]                       wc_o;
  wire [NUM_RX_LANE*8-1:0]          bd_o;
  wire [7:0]                        ecc_o;

  wire                              sp2_en_o;
  wire                              lp2_en_o;
  wire                              lp2_av_en_o;
  wire [5:0]                        dt2_o;
  wire [1:0]                        vc2_o;
  wire [15:0]                       wc2_o;
  wire [7:0]                        ecc2_o;

  wire                              payload_en_o;
  wire [NUM_RX_LANE*RX_GEAR-1:0]    payload_o;

  wire                              term_clk_en_o;
  wire                              hs_d_en_o;
  wire [1:0]                        lp_hs_state_clk_o;
  wire [1:0]                        lp_hs_state_d_o;
  wire                              hs_sync_o;
  /// END
   //DUT port output
   wire clk_pixel_w;
   wire vsync_w;
   wire hsync_w;
   wire de_w;
   wire fv_w;
   wire lv_w;
   // wire [`CMOS_DWIDTH-1:0] rgb_red_w;
   // wire [`CMOS_DWIDTH-1:0] rgb_green_w;
   // wire [`CMOS_DWIDTH-1:0] rgb_blue_w;
   // wire [`CMOS_DWIDTH-1:0] raw_w;
   // wire [`CMOS_DWIDTH-1:0] yuv_w;

    reg reset_lp_w=1;
    reg reset_byte_fr_w=1;
    reg reset_byte_w=1;
    reg system_reset_w=1;
    
    reg [5:0] ref_dt_i = VIDEO_DATA_TYPE;

//   assign resetn = system_reset_w;

   wire clk_byte_fr; //used to connect clk_byte_fr_i to clk_byte_hs_o

   //generate clk for clk_lp_ctrl_i  = 50MHz
   reg lp_ctrl_clk=0;
   always #(10000) lp_ctrl_clk = ~lp_ctrl_clk;

   // initial begin
      // $shm_open("./dump.shm");
      // $shm_probe(tb, ("AC"));
   // end

  generate
    if (RX_CLK_MODE == "HS_LP") begin
       always #(refclk_period/2) refclk_i =~ refclk_i;
    end
    ///
    if (RX_TYPE == "CSI2") begin
        always #(dphy_clk_period/2) cont_clk =~ cont_clk;
    end
  endgenerate


    //DUT instance
   PUR PUR_INST(system_reset_w); //resetn

generate
  if (RX_TYPE == "DSI") begin : DSI_MODEL

    wire clk_p_w;
    wire clk_n_w;

    wire d0_p_w;
    wire d0_n_w;
    wire d1_p_w;
    wire d1_n_w;
    wire d2_p_w;
    wire d2_n_w;
    wire d3_p_w;
    wire d3_n_w;

    assign d0_p_io_w = d0_p_w;
    assign d0_n_io_w = d0_n_w;
    assign d1_p_i_w  = d1_p_w;
    assign d1_n_i_w  = d1_n_w;
    assign d2_p_i_w  = d2_p_w;
    assign d2_n_i_w  = d2_n_w;
    assign d3_p_i_w  = d3_p_w;
    assign d3_n_i_w  = d3_n_w;
    assign clk_p_i_w = clk_p_w;
    assign clk_n_i_w = clk_n_w;

    dsi_model #(
      .dphy_num_lane     (NUM_RX_LANE      ),
      .dphy_clk_period   (dphy_clk_period  ),
      .num_frames        (num_frames       ),
      .num_lines         (num_lines        ),
      .rx_clk_mode       (RX_CLK_MODE      ),
      .SOT_DRIVE_EDGE    (SOT_DRIVE_EDGE   ),
      .NULL_PACKET       (NULL_PACKET      ),
      .t_lpx             (t_lpx            ),
      .t_clk_prepare     (t_clk_prepare    ),
      .t_clk_zero        (t_clk_zero       ),
      .t_clk_pre         (t_clk_pre        ),
      .t_clk_post        (t_clk_post       ),
      .t_clk_trail       (t_clk_trail      ),
      .t_hs_prepare      (t_hs_prepare     ),
      .t_hs_zero         (t_hs_zero        ),
      .t_hs_trail        (t_hs_trail       ),
      .t_init            (init_delay       ),
      .hsa_payload       (hsa_payload      ),
      .bllp_payload      (bllp_payload     ),
      .hbp_payload       (hbp_payload      ),
      .hfp_payload       (hfp_payload      ),
      .lps_bllp_duration (lps_bllp_duration),
      .lps_hfp_duration  (lps_hfp_duration ),
      .lps_hbp_duration  (lps_hbp_duration ),
      .vact_payload      (vact_payload     ),
      .virtual_channel   (virtual_channel  ),
      .video_data_type   (VIDEO_DATA_TYPE  ),
      .vsa_lines         (vsa_lines        ),
      .vbp_lines         (vbp_lines        ),
      .vfp_lines         (vfp_lines        ),
      .eotp_enable       (eotp_enable      ),
      .frame_gap         (frame_gap        ),
      .debug_on          (debug_on         )
    )
    dsi_ch0 (
      .resetn(system_reset_w), //resetn
      .clk_p_i(clk_p_w),
      .clk_n_i(clk_n_w),
      .d0_p_io(d0_p_w),
      .d0_n_io(d0_n_w),
      .d1_p_i (d1_p_w),
      .d1_n_i (d1_n_w),
      .d2_p_i (d2_p_w),
      .d2_n_i (d2_n_w),
      .d3_p_i (d3_p_w),
      .d3_n_i (d3_n_w)
    );

       initial begin
      $timeformat(-12,0,"",10);
      refclk_i      = 0;
      cont_clk      = 0;
      dsi_ch0.eotb  = 0;
      eotb          = 0;
      fork
        begin
          reset_byte;
        end
        begin
          drive_reset;
          if(dphy_clk_period%2 > 0) begin
             dphy_clk = dphy_clk_period - 1;
          end
          else begin
             dphy_clk = dphy_clk_period;
          end

          $display("%0t TEST START\n",$realtime);
          #(dphy_clk_period*12*3);

          #(init_delay); //wait initialization delay

             dsi_ch0.dphy_active = 1;
             $display("%t Activating DSI model\n", $time);
             @(negedge dsi_ch0.dphy_active);
          #100000;
          $display("%0t TEST END\n",$realtime);
          dsi_ch0.eotb  = 1;
          eotb          = 1;
          #1;
          text_comp_t();
         end
      join
   end

  end
  else begin : CSI2_MODEL
    wire [3:0] dphy_data_p_i;
    wire [3:0] dphy_data_n_i;
    wire clk_p_w1;
    wire clk_n_w1;
    wire clk_p_w2;
    wire clk_n_w2;

    assign d0_p_io_w = dphy_data_p_i[0];
    assign d0_n_io_w = dphy_data_n_i[0];
    assign d1_p_i_w = dphy_data_p_i[1];
    assign d1_n_i_w = dphy_data_n_i[1];
    assign d2_p_i_w = dphy_data_p_i[2];
    assign d2_n_i_w = dphy_data_n_i[2];
    assign d3_p_i_w = dphy_data_p_i[3];
    assign d3_n_i_w = dphy_data_n_i[3];

    csi2_model #(
      .active_dphy_lanes (NUM_RX_LANE      ),
      .SOT_DRIVE_EDGE    (SOT_DRIVE_EDGE   ),
      .NULL_PACKET       (NULL_PACKET      ),
      .num_frames        (num_frames       ),
      .num_lines         (num_lines        ),
      .num_pixels        (num_pixels       ),
      .data_type         (VIDEO_DATA_TYPE  ),
      .dphy_clk_period   (dphy_clk_period  ),
      .rx_clk_mode       (RX_CLK_MODE      ),
      .t_lpx             (t_lpx            ),
      .t_clk_prepare     (t_clk_prepare    ),
      .t_clk_zero        (t_clk_zero       ),
      .t_clk_pre         (t_clk_pre        ),
      .t_clk_post        (t_clk_post       ),
      .t_clk_trail       (t_clk_trail      ),
      .t_hs_prepare      (t_hs_prepare     ),
      .t_hs_zero         (t_hs_zero        ),
      .t_hs_trail        (t_hs_trail       ),
      .lps_gap           (lps_gap          ),
      .frame_gap         (frame_gap        ),
      .t_init            (init_delay       ),
      .dphy_ch           (0                ),
      .dphy_vc           (virtual_channel  ),
      .long_even_line_en (long_even_line_en),
      .ls_le_en          (ls_le_en         ),
      .debug             (debug_on         )
    )
    csi2_ch0 (
      .resetn       (                                 ), //resetn
      .refclk_i     (cont_clk),
      .clk_p_i      (clk_p_w1),
      .clk_n_i      (clk_n_w1),
      .cont_clk_p_i (clk_p_w2),
      .cont_clk_n_i (clk_n_w2),
      .do_p_i       (dphy_data_p_i),
      .do_n_i       (dphy_data_n_i)
   );

      initial begin
      $timeformat(-12,0,"",10);
      refclk_i = 0;
      cont_clk = 0;
      csi2_ch0.eotb = 0;
      eotb          = 0;
      fork
        begin
          reset_byte;
        end
        begin
          drive_reset;
          if(dphy_clk_period%2 > 0) begin
             dphy_clk = dphy_clk_period - 1;
          end
          else begin
             dphy_clk = dphy_clk_period;
          end

          $display("%0t TEST START\n",$realtime);
          #(dphy_clk_period*12*3);

          #(init_delay); //wait initialization delay

          csi2_ch0.dphy_active = 1;
          $display("%t Activating CSI2 model\n", $time);
          @(negedge csi2_ch0.dphy_active);
          #100000;
          $display("%0t TEST END\n",$realtime);
          csi2_ch0.eotb = 1;
          eotb          = 1;
          #1;
         end
      join
         text_comp_t;
      // $finish;
   end

   assign clk_p_i_w = (RX_CLK_MODE == "HS_LP")? clk_p_w1 : clk_p_w2;
   assign clk_n_i_w = (RX_CLK_MODE == "HS_LP")? clk_n_w1 : clk_n_w2;

  end
endgenerate

/// DUT instance
  assign clk_byte_fr_i     = (RX_CLK_MODE == "HS_ONLY")? clk_byte_fr : refclk_i;
  assign clk_p_i           = clk_p_i_w;
  assign clk_n_i           = clk_n_i_w;
  assign d0_p_io           = (RX_TYPE ==  "DSI")? d0_p_io_w : 1'dz;
  assign d0_n_io           = (RX_TYPE ==  "DSI")? d0_n_io_w : 1'dz;
  assign d0_p_i            = (RX_TYPE == "CSI2")? d0_p_io_w : 1'dz;
  assign d0_n_i            = (RX_TYPE == "CSI2")? d0_n_io_w : 1'dz;
  assign d1_p_i            = d1_p_i_w;
  assign d1_n_i            = d1_n_i_w;
  assign d2_p_i            = d2_p_i_w;
  assign d2_n_i            = d2_n_i_w;
  assign d3_p_i            = d3_p_i_w;
  assign d3_n_i            = d3_n_i_w;
  assign pll_lock_i        = 1;
  assign clk_lp_ctrl_i     = lp_ctrl_clk;
  assign clk_byte_fr       = (RX_CLK_MODE == "HS_ONLY")? clk_byte_hs_o : 1'dz;
  assign lp_d0_tx_en_i     = 0;
  assign lp_d0_tx_n_i      = 0;
  assign lp_d0_tx_p_i      = 0;
  assign reset_lp_n_i      = reset_lp_w;
  assign reset_byte_fr_n_i = reset_byte_fr_w;
  assign reset_byte_n_i    = reset_byte_w;
  assign reset_n_i         = system_reset_w;

  `include"dut_inst.v"

     task drive_reset();
       begin
       fork
         begin reset_lp;      end
         begin reset_byte_fr; end
         begin system_reset;  end
       join
       end
     endtask

     task reset_lp();
       begin
       reset_lp_w = 0;
       @(posedge lp_ctrl_clk);
       #1;
       reset_lp_w = 1;
       end
     endtask

     task reset_byte_fr();
       begin
       reset_byte_fr_w = 0;
       #10;
       // @(posedge I_dphy_rx.clk_byte_fr_i);/// ???
       @(posedge clk_byte_fr_i);
       #1;
       reset_byte_fr_w = 1;
       end
     endtask

     task reset_byte();
       begin
       reset_byte_w = 0;
       #10;
       // @(posedge I_dphy_rx.clk_byte_hs_o);/// ???
       @(posedge clk_byte_hs_o);
       #1;
       reset_byte_w = 1;
       end
     endtask

     task system_reset();
       begin
       system_reset_w = 0;
       #(refclk_period);
       system_reset_w = 1;
       end
     endtask

    task text_comp_t;// Task which compare two text files
      integer status_1;
      integer status_2;
      integer true_res;
      integer false_res;
      integer file_1_value;
      integer file_2_value;
      integer file_1;
      integer file_2;
      begin
        status_1       = 0;
        status_2       = 0;
        true_res       = 32'd0;
        false_res      = 32'd0;
        file_1_value   = 32'd0;
        file_2_value   = 32'd0;
        file_1         = $fopen("rx_crc_file.txt","r");
        file_2         = $fopen("tx_model_crc_file.txt","r");
        #1;
        if(NUM_RX_LANE == 3) begin
          $display("Not a check for this case");
          $finish;
        end
        else begin
          $display("Start of CRC comparing");
          while (!$feof(file_1) | !$feof(file_1)) begin
            #1;
            status_1 = $fscanf(file_1,"%h\n",file_1_value);
            status_2 = $fscanf(file_2,"%h\n",file_2_value);
            #1;
            if (file_1_value == file_2_value) begin
              true_res   = true_res + 1;
            end
            else begin
              false_res  = false_res + 1;
              // $display("Time : %0t ps Error %h from test not equal to %h from DUT",$realtime,file_1_value,file_2_value);
            end
          end
          $fclose(file_1);
          $fclose(file_2);
          $display("End of CRC comparing");
          if (false_res == 0 & true_res != 0) begin
            $display("*** SIMULATION PASSED ***");
          end
          else if (false_res != 0) begin
            $display("****** TEST FAILED ******");
          end
          else begin
            $display("Something goes wrong");
          end
          
          // $display("Errors` ",false_res,"/",false_res + true_res);
          $finish;
        end
      end
    endtask


//------------------------------------------------------------------------------
// Function Definition
//------------------------------------------------------------------------------  
function [15:0] nextCRC16_D64;
    input [63:0] Data;
    input [15:0] crc;
    reg [63:0] d;
    reg [15:0] c;
    reg [15:0] newcrc;
  begin
    d = Data;
    c = crc;

    newcrc[0] = d[63] ^ d[58] ^ d[56] ^ d[55] ^ d[52] ^ d[51] ^ d[49] ^ d[48] ^ d[42] ^ d[35] ^ d[33] ^ d[32] ^ d[28] ^ d[27] ^ d[26] ^ d[22] ^ d[20] ^ d[19] ^ d[12] ^ d[11] ^ d[8] ^ d[4] ^ d[0] ^ c[0] ^ c[1] ^ c[3] ^ c[4] ^ c[7] ^ c[8] ^ c[10] ^ c[15];
    newcrc[1] = d[59] ^ d[57] ^ d[56] ^ d[53] ^ d[52] ^ d[50] ^ d[49] ^ d[43] ^ d[36] ^ d[34] ^ d[33] ^ d[29] ^ d[28] ^ d[27] ^ d[23] ^ d[21] ^ d[20] ^ d[13] ^ d[12] ^ d[9] ^ d[5] ^ d[1] ^ c[1] ^ c[2] ^ c[4] ^ c[5] ^ c[8] ^ c[9] ^ c[11];
    newcrc[2] = d[60] ^ d[58] ^ d[57] ^ d[54] ^ d[53] ^ d[51] ^ d[50] ^ d[44] ^ d[37] ^ d[35] ^ d[34] ^ d[30] ^ d[29] ^ d[28] ^ d[24] ^ d[22] ^ d[21] ^ d[14] ^ d[13] ^ d[10] ^ d[6] ^ d[2] ^ c[2] ^ c[3] ^ c[5] ^ c[6] ^ c[9] ^ c[10] ^ c[12];
    newcrc[3] = d[61] ^ d[59] ^ d[58] ^ d[55] ^ d[54] ^ d[52] ^ d[51] ^ d[45] ^ d[38] ^ d[36] ^ d[35] ^ d[31] ^ d[30] ^ d[29] ^ d[25] ^ d[23] ^ d[22] ^ d[15] ^ d[14] ^ d[11] ^ d[7] ^ d[3] ^ c[3] ^ c[4] ^ c[6] ^ c[7] ^ c[10] ^ c[11] ^ c[13];
    newcrc[4] = d[62] ^ d[60] ^ d[59] ^ d[56] ^ d[55] ^ d[53] ^ d[52] ^ d[46] ^ d[39] ^ d[37] ^ d[36] ^ d[32] ^ d[31] ^ d[30] ^ d[26] ^ d[24] ^ d[23] ^ d[16] ^ d[15] ^ d[12] ^ d[8] ^ d[4] ^ c[4] ^ c[5] ^ c[7] ^ c[8] ^ c[11] ^ c[12] ^ c[14];
    newcrc[5] = d[61] ^ d[60] ^ d[58] ^ d[57] ^ d[55] ^ d[54] ^ d[53] ^ d[52] ^ d[51] ^ d[49] ^ d[48] ^ d[47] ^ d[42] ^ d[40] ^ d[38] ^ d[37] ^ d[35] ^ d[31] ^ d[28] ^ d[26] ^ d[25] ^ d[24] ^ d[22] ^ d[20] ^ d[19] ^ d[17] ^ d[16] ^ d[13] ^ d[12] ^ d[11] ^ d[9] ^ d[8] ^ d[5] ^ d[4] ^ d[0] ^ c[0] ^ c[1] ^ c[3] ^ c[4] ^ c[5] ^ c[6] ^ c[7] ^ c[9] ^ c[10] ^ c[12] ^ c[13];
    newcrc[6] = d[62] ^ d[61] ^ d[59] ^ d[58] ^ d[56] ^ d[55] ^ d[54] ^ d[53] ^ d[52] ^ d[50] ^ d[49] ^ d[48] ^ d[43] ^ d[41] ^ d[39] ^ d[38] ^ d[36] ^ d[32] ^ d[29] ^ d[27] ^ d[26] ^ d[25] ^ d[23] ^ d[21] ^ d[20] ^ d[18] ^ d[17] ^ d[14] ^ d[13] ^ d[12] ^ d[10] ^ d[9] ^ d[6] ^ d[5] ^ d[1] ^ c[0] ^ c[1] ^ c[2] ^ c[4] ^ c[5] ^ c[6] ^ c[7] ^ c[8] ^ c[10] ^ c[11] ^ c[13] ^ c[14];
    newcrc[7] = d[63] ^ d[62] ^ d[60] ^ d[59] ^ d[57] ^ d[56] ^ d[55] ^ d[54] ^ d[53] ^ d[51] ^ d[50] ^ d[49] ^ d[44] ^ d[42] ^ d[40] ^ d[39] ^ d[37] ^ d[33] ^ d[30] ^ d[28] ^ d[27] ^ d[26] ^ d[24] ^ d[22] ^ d[21] ^ d[19] ^ d[18] ^ d[15] ^ d[14] ^ d[13] ^ d[11] ^ d[10] ^ d[7] ^ d[6] ^ d[2] ^ c[1] ^ c[2] ^ c[3] ^ c[5] ^ c[6] ^ c[7] ^ c[8] ^ c[9] ^ c[11] ^ c[12] ^ c[14] ^ c[15];
    newcrc[8] = d[63] ^ d[61] ^ d[60] ^ d[58] ^ d[57] ^ d[56] ^ d[55] ^ d[54] ^ d[52] ^ d[51] ^ d[50] ^ d[45] ^ d[43] ^ d[41] ^ d[40] ^ d[38] ^ d[34] ^ d[31] ^ d[29] ^ d[28] ^ d[27] ^ d[25] ^ d[23] ^ d[22] ^ d[20] ^ d[19] ^ d[16] ^ d[15] ^ d[14] ^ d[12] ^ d[11] ^ d[8] ^ d[7] ^ d[3] ^ c[2] ^ c[3] ^ c[4] ^ c[6] ^ c[7] ^ c[8] ^ c[9] ^ c[10] ^ c[12] ^ c[13] ^ c[15];
    newcrc[9] = d[62] ^ d[61] ^ d[59] ^ d[58] ^ d[57] ^ d[56] ^ d[55] ^ d[53] ^ d[52] ^ d[51] ^ d[46] ^ d[44] ^ d[42] ^ d[41] ^ d[39] ^ d[35] ^ d[32] ^ d[30] ^ d[29] ^ d[28] ^ d[26] ^ d[24] ^ d[23] ^ d[21] ^ d[20] ^ d[17] ^ d[16] ^ d[15] ^ d[13] ^ d[12] ^ d[9] ^ d[8] ^ d[4] ^ c[3] ^ c[4] ^ c[5] ^ c[7] ^ c[8] ^ c[9] ^ c[10] ^ c[11] ^ c[13] ^ c[14];
    newcrc[10] = d[63] ^ d[62] ^ d[60] ^ d[59] ^ d[58] ^ d[57] ^ d[56] ^ d[54] ^ d[53] ^ d[52] ^ d[47] ^ d[45] ^ d[43] ^ d[42] ^ d[40] ^ d[36] ^ d[33] ^ d[31] ^ d[30] ^ d[29] ^ d[27] ^ d[25] ^ d[24] ^ d[22] ^ d[21] ^ d[18] ^ d[17] ^ d[16] ^ d[14] ^ d[13] ^ d[10] ^ d[9] ^ d[5] ^ c[4] ^ c[5] ^ c[6] ^ c[8] ^ c[9] ^ c[10] ^ c[11] ^ c[12] ^ c[14] ^ c[15];
    newcrc[11] = d[63] ^ d[61] ^ d[60] ^ d[59] ^ d[58] ^ d[57] ^ d[55] ^ d[54] ^ d[53] ^ d[48] ^ d[46] ^ d[44] ^ d[43] ^ d[41] ^ d[37] ^ d[34] ^ d[32] ^ d[31] ^ d[30] ^ d[28] ^ d[26] ^ d[25] ^ d[23] ^ d[22] ^ d[19] ^ d[18] ^ d[17] ^ d[15] ^ d[14] ^ d[11] ^ d[10] ^ d[6] ^ c[0] ^ c[5] ^ c[6] ^ c[7] ^ c[9] ^ c[10] ^ c[11] ^ c[12] ^ c[13] ^ c[15];
    newcrc[12] = d[63] ^ d[62] ^ d[61] ^ d[60] ^ d[59] ^ d[54] ^ d[52] ^ d[51] ^ d[48] ^ d[47] ^ d[45] ^ d[44] ^ d[38] ^ d[31] ^ d[29] ^ d[28] ^ d[24] ^ d[23] ^ d[22] ^ d[18] ^ d[16] ^ d[15] ^ d[8] ^ d[7] ^ d[4] ^ d[0] ^ c[0] ^ c[3] ^ c[4] ^ c[6] ^ c[11] ^ c[12] ^ c[13] ^ c[14] ^ c[15];
    newcrc[13] = d[63] ^ d[62] ^ d[61] ^ d[60] ^ d[55] ^ d[53] ^ d[52] ^ d[49] ^ d[48] ^ d[46] ^ d[45] ^ d[39] ^ d[32] ^ d[30] ^ d[29] ^ d[25] ^ d[24] ^ d[23] ^ d[19] ^ d[17] ^ d[16] ^ d[9] ^ d[8] ^ d[5] ^ d[1] ^ c[0] ^ c[1] ^ c[4] ^ c[5] ^ c[7] ^ c[12] ^ c[13] ^ c[14] ^ c[15];
    newcrc[14] = d[63] ^ d[62] ^ d[61] ^ d[56] ^ d[54] ^ d[53] ^ d[50] ^ d[49] ^ d[47] ^ d[46] ^ d[40] ^ d[33] ^ d[31] ^ d[30] ^ d[26] ^ d[25] ^ d[24] ^ d[20] ^ d[18] ^ d[17] ^ d[10] ^ d[9] ^ d[6] ^ d[2] ^ c[1] ^ c[2] ^ c[5] ^ c[6] ^ c[8] ^ c[13] ^ c[14] ^ c[15];
    newcrc[15] = d[63] ^ d[62] ^ d[57] ^ d[55] ^ d[54] ^ d[51] ^ d[50] ^ d[48] ^ d[47] ^ d[41] ^ d[34] ^ d[32] ^ d[31] ^ d[27] ^ d[26] ^ d[25] ^ d[21] ^ d[19] ^ d[18] ^ d[11] ^ d[10] ^ d[7] ^ d[3] ^ c[0] ^ c[2] ^ c[3] ^ c[6] ^ c[7] ^ c[9] ^ c[14] ^ c[15];
    nextCRC16_D64 = newcrc;
  end
  endfunction
function [15:0] nextCRC16_D32;
  input [31:0] Data;
  input [15:0] crc_o;
  reg   [31:0] d;
  reg   [15:0] c;
  reg   [15:0] newcrc;
begin
  d          = Data;
  c          = crc_o;

  newcrc[0]  = d[28] ^ d[27] ^ d[26] ^ d[22] ^ d[20] ^ d[19] ^ d[12] ^ d[11] ^
               d[ 8] ^ d[ 4] ^ d[ 0] ^ c[ 3] ^ c[ 4] ^ c[ 6] ^ c[10] ^ c[11] ^
               c[12];
  newcrc[1]  = d[29] ^ d[28] ^ d[27] ^ d[23] ^ d[21] ^ d[20] ^ d[13] ^ d[12] ^
               d[ 9] ^ d[ 5] ^ d[ 1] ^ c[ 4] ^ c[ 5] ^ c[ 7] ^ c[11] ^ c[12] ^
               c[13];
  newcrc[2]  = d[30] ^ d[29] ^ d[28] ^ d[24] ^ d[22] ^ d[21] ^ d[14] ^ d[13] ^
               d[10] ^ d[ 6] ^ d[ 2] ^ c[ 5] ^ c[ 6] ^ c[ 8] ^ c[12] ^ c[13] ^
               c[14];
  newcrc[3]  = d[31] ^ d[30] ^ d[29] ^ d[25] ^ d[23] ^ d[22] ^ d[15] ^ d[14] ^
               d[11] ^ d[ 7] ^ d[ 3] ^ c[ 6] ^ c[ 7] ^ c[ 9] ^ c[13] ^ c[14] ^
               c[15];
  newcrc[4]  = d[31] ^ d[30] ^ d[26] ^ d[24] ^ d[23] ^ d[16] ^ d[15] ^ d[12] ^
               d[ 8] ^ d[ 4] ^ c[ 0] ^ c[ 7] ^ c[ 8] ^ c[10] ^ c[14] ^ c[15];
  newcrc[5]  = d[31] ^ d[28] ^ d[26] ^ d[25] ^ d[24] ^ d[22] ^ d[20] ^ d[19] ^
               d[17] ^ d[16] ^ d[13] ^ d[12] ^ d[11] ^ d[ 9] ^ d[ 8] ^ d[ 5] ^
               d[ 4] ^ d[ 0] ^ c[ 0] ^ c[ 1] ^ c[ 3] ^ c[ 4] ^ c[ 6] ^ c[ 8] ^
               c[ 9] ^ c[10] ^ c[12] ^ c[15];
  newcrc[6]  = d[29] ^ d[27] ^ d[26] ^ d[25] ^ d[23] ^ d[21] ^ d[20] ^ d[18] ^
               d[17] ^ d[14] ^ d[13] ^ d[12] ^ d[10] ^ d[ 9] ^ d[ 6] ^ d[ 5] ^
               d[ 1] ^ c[ 1] ^ c[ 2] ^ c[ 4] ^ c[ 5] ^ c[ 7] ^ c[ 9] ^ c[10] ^
               c[11] ^ c[13];
  newcrc[7]  = d[30] ^ d[28] ^ d[27] ^ d[26] ^ d[24] ^ d[22] ^ d[21] ^ d[19] ^
               d[18] ^ d[15] ^ d[14] ^ d[13] ^ d[11] ^ d[10] ^ d[ 7] ^ d[ 6] ^
               d[ 2] ^ c[ 2] ^ c[ 3] ^ c[ 5] ^ c[ 6] ^ c[ 8] ^ c[10] ^ c[11] ^
               c[12] ^ c[14];
  newcrc[8]  = d[31] ^ d[29] ^ d[28] ^ d[27] ^ d[25] ^ d[23] ^ d[22] ^ d[20] ^
               d[19] ^ d[16] ^ d[15] ^ d[14] ^ d[12] ^ d[11] ^ d[ 8] ^ d[ 7] ^
               d[ 3] ^ c[ 0] ^ c[ 3] ^ c[ 4] ^ c[ 6] ^ c[ 7] ^ c[ 9] ^ c[11] ^
               c[12] ^ c[13] ^ c[15];
  newcrc[9]  = d[30] ^ d[29] ^ d[28] ^ d[26] ^ d[24] ^ d[23] ^ d[21] ^ d[20] ^
               d[17] ^ d[16] ^ d[15] ^ d[13] ^ d[12] ^ d[ 9] ^ d[ 8] ^ d[ 4] ^
               c[ 0] ^ c[ 1] ^ c[ 4] ^ c[ 5] ^ c[ 7] ^ c[ 8] ^ c[10] ^ c[12] ^
               c[13] ^ c[14];
  newcrc[10] = d[31] ^ d[30] ^ d[29] ^ d[27] ^ d[25] ^ d[24] ^ d[22] ^ d[21] ^
               d[18] ^ d[17] ^ d[16] ^ d[14] ^ d[13] ^ d[10] ^ d[ 9] ^ d[ 5] ^
               c[ 0] ^ c[ 1] ^ c[ 2] ^ c[ 5] ^ c[ 6] ^ c[ 8] ^ c[ 9] ^ c[11] ^
               c[13] ^ c[14] ^ c[15];
  newcrc[11] = d[31] ^ d[30] ^ d[28] ^ d[26] ^ d[25] ^ d[23] ^ d[22] ^ d[19] ^
               d[18] ^ d[17] ^ d[15] ^ d[14] ^ d[11] ^ d[10] ^ d[ 6] ^ c[ 1] ^
               c[ 2] ^ c[ 3] ^ c[ 6] ^ c[ 7] ^ c[ 9] ^ c[10] ^ c[12] ^ c[14] ^
               c[15];
  newcrc[12] = d[31] ^ d[29] ^ d[28] ^ d[24] ^ d[23] ^ d[22] ^ d[18] ^ d[16] ^
               d[15] ^ d[ 8] ^ d[ 7] ^ d[ 4] ^ d[ 0] ^ c[ 0] ^ c[ 2] ^ c[ 6] ^
               c[ 7] ^ c[ 8] ^ c[12] ^ c[13] ^ c[15];
  newcrc[13] = d[30] ^ d[29] ^ d[25] ^ d[24] ^ d[23] ^ d[19] ^ d[17] ^ d[16] ^
               d[ 9] ^ d[ 8] ^ d[ 5] ^ d[ 1] ^ c[ 0] ^ c[ 1] ^ c[ 3] ^ c[ 7] ^
               c[ 8] ^ c[ 9] ^ c[13] ^ c[14];
  newcrc[14] = d[31] ^ d[30] ^ d[26] ^ d[25] ^ d[24] ^ d[20] ^ d[18] ^ d[17] ^
               d[10] ^ d[ 9] ^ d[ 6] ^ d[ 2] ^ c[ 1] ^ c[ 2] ^ c[ 4] ^ c[ 8] ^
               c[ 9] ^ c[10] ^ c[14] ^ c[15];
  newcrc[15] = d[31] ^ d[27] ^ d[26] ^ d[25] ^ d[21] ^ d[19] ^ d[18] ^ d[11] ^
               d[10] ^ d[ 7] ^ d[ 3] ^ c[ 2] ^ c[ 3] ^ c[ 5] ^ c[ 9] ^ c[10] ^
               c[11] ^ c[15];
  nextCRC16_D32 = newcrc;
end
endfunction

function [15:0] nextCRC16_D24;
  input [23:0] Data;
  input [15:0] crc;
  reg   [23:0] d;
  reg   [15:0] c;
  reg   [15:0] newcrc;
begin
  d             = Data;
  c             = crc;

  newcrc[ 0]    = d[22] ^ d[20] ^ d[19] ^ d[12] ^ d[11] ^ d[ 8] ^ d[ 4] ^
                  d[ 0] ^ c[ 0] ^ c[ 3] ^ c[ 4] ^ c[11] ^ c[12] ^ c[14];
  newcrc[ 1]    = d[23] ^ d[21] ^ d[20] ^ d[13] ^ d[12] ^ d[ 9] ^ d[ 5] ^
                  d[ 1] ^ c[ 1] ^ c[ 4] ^ c[ 5] ^ c[12] ^ c[13] ^ c[15];
  newcrc[ 2]    = d[22] ^ d[21] ^ d[14] ^ d[13] ^ d[10] ^ d[ 6] ^ d[ 2] ^
                  c[ 2] ^ c[ 5] ^ c[ 6] ^ c[13] ^ c[14];
  newcrc[ 3]    = d[23] ^ d[22] ^ d[15] ^ d[14] ^ d[11] ^ d[ 7] ^ d[ 3] ^
                  c[ 3] ^ c[ 6] ^ c[ 7] ^ c[14] ^ c[15];
  newcrc[ 4]    = d[23] ^ d[16] ^ d[15] ^ d[12] ^ d[ 8] ^ d[ 4] ^ c[ 0] ^
                  c[ 4] ^ c[ 7] ^ c[ 8] ^ c[15];
  newcrc[ 5]    = d[22] ^ d[20] ^ d[19] ^ d[17] ^ d[16] ^ d[13] ^ d[12] ^
                  d[11] ^ d[ 9] ^ d[ 8] ^ d[ 5] ^ d[ 4] ^ d[ 0] ^ c[ 0] ^
                  c[ 1] ^ c[ 3] ^ c[ 4] ^ c[ 5] ^ c[ 8] ^ c[ 9] ^ c[11] ^
                  c[12] ^ c[14];
  newcrc[ 6]    = d[23] ^ d[21] ^ d[20] ^ d[18] ^ d[17] ^ d[14] ^ d[13] ^
                  d[12] ^ d[10] ^ d[ 9] ^ d[ 6] ^ d[ 5] ^ d[ 1] ^ c[ 1] ^
                  c[ 2] ^ c[ 4] ^ c[ 5] ^ c[ 6] ^ c[ 9] ^ c[10] ^ c[12] ^
                  c[13] ^ c[15];
  newcrc[ 7]    = d[22] ^ d[21] ^ d[19] ^ d[18] ^ d[15] ^ d[14] ^ d[13] ^
                  d[11] ^ d[10] ^ d[ 7] ^ d[ 6] ^ d[ 2] ^ c[ 2] ^ c[ 3] ^
                  c[ 5] ^ c[ 6] ^ c[ 7] ^ c[10] ^ c[11] ^ c[13] ^ c[14];
  newcrc[ 8]    = d[23] ^ d[22] ^ d[20] ^ d[19] ^ d[16] ^ d[15] ^ d[14] ^
                  d[12] ^ d[11] ^ d[ 8] ^ d[ 7] ^ d[ 3] ^ c[ 0] ^ c[ 3] ^
                  c[ 4] ^ c[ 6] ^ c[ 7] ^ c[ 8] ^ c[11] ^ c[12] ^ c[14] ^
                  c[15];
  newcrc[ 9]    = d[23] ^ d[21] ^ d[20] ^ d[17] ^ d[16] ^ d[15] ^ d[13] ^
                  d[12] ^ d[ 9] ^ d[ 8] ^ d[ 4] ^ c[ 0] ^ c[ 1] ^ c[ 4] ^
                  c[ 5] ^ c[ 7] ^ c[ 8] ^ c[ 9] ^ c[12] ^ c[13] ^ c[15];
  newcrc[10]    = d[22] ^ d[21] ^ d[18] ^ d[17] ^ d[16] ^ d[14] ^ d[13] ^
                  d[10] ^ d[ 9] ^ d[ 5] ^ c[ 1] ^ c[ 2] ^ c[ 5] ^ c[ 6] ^
                  c[ 8] ^ c[ 9] ^ c[10] ^ c[13] ^ c[14];
  newcrc[11]    = d[23] ^ d[22] ^ d[19] ^ d[18] ^ d[17] ^ d[15] ^ d[14] ^
                  d[11] ^ d[10] ^ d[ 6] ^ c[ 2] ^ c[ 3] ^ c[ 6] ^ c[ 7] ^
                  c[ 9] ^ c[10] ^ c[11] ^ c[14] ^ c[15];
  newcrc[12]    = d[23] ^ d[22] ^ d[18] ^ d[16] ^ d[15] ^ d[ 8] ^ d[ 7] ^
                  d[ 4] ^ d[ 0] ^ c[ 0] ^ c[ 7] ^ c[ 8] ^ c[10] ^ c[14] ^
                  c[15];
  newcrc[13]    = d[23] ^ d[19] ^ d[17] ^ d[16] ^ d[ 9] ^ d[ 8] ^ d[ 5] ^
                  d[ 1] ^ c[ 0] ^ c[ 1] ^ c[ 8] ^ c[ 9] ^ c[11] ^ c[15];
  newcrc[14]    = d[20] ^ d[18] ^ d[17] ^ d[10] ^ d[ 9] ^ d[ 6] ^ d[ 2] ^
                  c[ 1] ^ c[ 2] ^ c[ 9] ^ c[10] ^ c[12];
  newcrc[15]    = d[21] ^ d[19] ^ d[18] ^ d[11] ^ d[10] ^ d[ 7] ^ d[ 3] ^
                  c[ 2] ^ c[ 3] ^ c[10] ^ c[11] ^ c[13];
  nextCRC16_D24 = newcrc;
end
endfunction

function [15:0] nextCRC16_D16;
  input [15:0] Data;
  input [15:0] crc_o;
  reg   [15:0] d;
  reg   [15:0] c;
  reg   [15:0] newcrc;
begin
  d             = Data;
  c             = crc_o;

  newcrc[0]     = d[12] ^ d[11] ^ d[ 8] ^ d[ 4] ^ d[ 0] ^ c[ 0] ^ c[ 4] ^
                  c[ 8] ^ c[11] ^ c[12];
  newcrc[1]     = d[13] ^ d[12] ^ d[ 9] ^ d[ 5] ^ d[ 1] ^ c[ 1] ^ c[ 5] ^
                  c[ 9] ^ c[12] ^ c[13];
  newcrc[2]     = d[14] ^ d[13] ^ d[10] ^ d[ 6] ^ d[ 2] ^ c[ 2] ^ c[ 6] ^
                  c[10] ^ c[13] ^ c[14];
  newcrc[3]     = d[15] ^ d[14] ^ d[11] ^ d[ 7] ^ d[ 3] ^ c[ 3] ^ c[ 7] ^
                  c[11] ^ c[14] ^ c[15];
  newcrc[4]     = d[15] ^ d[12] ^ d[ 8] ^ d[ 4] ^ c[ 4] ^ c[ 8] ^ c[12] ^
                  c[15];
  newcrc[5]     = d[13] ^ d[12] ^ d[11] ^ d[ 9] ^ d[ 8] ^ d[ 5] ^ d[ 4] ^
                  d[ 0] ^ c[ 0] ^ c[ 4] ^ c[ 5] ^ c[ 8] ^ c[ 9] ^ c[11] ^
                  c[12] ^ c[13];
  newcrc[6]     = d[14] ^ d[13] ^ d[12] ^ d[10] ^ d[ 9] ^ d[ 6] ^ d[ 5] ^
                  d[ 1] ^ c[ 1] ^ c[ 5] ^ c[ 6] ^ c[ 9] ^ c[10] ^ c[12] ^
                  c[13] ^ c[14];
  newcrc[7]     = d[15] ^ d[14] ^ d[13] ^ d[11] ^ d[10] ^ d[ 7] ^ d[ 6] ^
                  d[ 2] ^ c[ 2] ^ c[ 6] ^ c[ 7] ^ c[10] ^ c[11] ^ c[13] ^
                  c[14] ^ c[15];
  newcrc[8]     = d[15] ^ d[14] ^ d[12] ^ d[11] ^ d[ 8] ^ d[ 7] ^ d[ 3] ^
                  c[ 3] ^ c[ 7] ^ c[ 8] ^ c[11] ^ c[12] ^ c[14] ^ c[15];
  newcrc[9]     = d[15] ^ d[13] ^ d[12] ^ d[ 9] ^ d[ 8] ^ d[ 4] ^ c[ 4] ^
                  c[ 8] ^ c[ 9] ^ c[12] ^ c[13] ^ c[15];
  newcrc[10]    = d[14] ^ d[13] ^ d[10] ^ d[ 9] ^ d[ 5] ^ c[ 5] ^ c[ 9] ^
                  c[10] ^ c[13] ^ c[14];
  newcrc[11]    = d[15] ^ d[14] ^ d[11] ^ d[10] ^ d[ 6] ^ c[ 6] ^ c[10] ^
                  c[11] ^ c[14] ^ c[15];
  newcrc[12]    = d[15] ^ d[ 8] ^ d[ 7] ^ d[ 4] ^ d[ 0] ^ c[ 0] ^ c[ 4] ^
                  c[ 7] ^ c[ 8] ^ c[15];
  newcrc[13]    = d[ 9] ^ d[ 8] ^ d[ 5] ^ d[ 1] ^ c[ 1] ^ c[ 5] ^ c[ 8] ^
                  c[ 9];
  newcrc[14]    = d[10] ^ d[ 9] ^ d[ 6] ^ d[ 2] ^ c[ 2] ^ c[ 6] ^ c[ 9] ^
                  c[10];
  newcrc[15]    = d[11] ^ d[10] ^ d[ 7] ^ d[ 3] ^ c[ 3] ^ c[ 7] ^ c[10] ^
                  c[11];
  nextCRC16_D16 = newcrc;
end
endfunction

function [15:0] nextCRC16_D8;
  input [7:0]  Data;
  input [15:0] crc_o;
  reg   [7:0]  d;
  reg   [15:0] c;
  reg   [15:0] newcrc;
begin
  d            = Data;
  c            = crc_o;
  newcrc[ 0]   = d[ 4] ^ d[ 0] ^ c[ 8] ^ c[12];
  newcrc[ 1]   = d[ 5] ^ d[ 1] ^ c[ 9] ^ c[13];
  newcrc[ 2]   = d[ 6] ^ d[ 2] ^ c[10] ^ c[14];
  newcrc[ 3]   = d[ 7] ^ d[ 3] ^ c[11] ^ c[15];
  newcrc[ 4]   = d[ 4] ^ c[12];
  newcrc[ 5]   = d[ 5] ^ d[ 4] ^ d[ 0] ^ c[ 8] ^ c[12] ^ c[13];
  newcrc[ 6]   = d[ 6] ^ d[ 5] ^ d[ 1] ^ c[ 9] ^ c[13] ^ c[14];
  newcrc[ 7]   = d[ 7] ^ d[ 6] ^ d[ 2] ^ c[10] ^ c[14] ^ c[15];
  newcrc[ 8]   = d[ 7] ^ d[ 3] ^ c[ 0] ^ c[11] ^ c[15];
  newcrc[ 9]   = d[ 4] ^ c[ 1] ^ c[12];
  newcrc[10]   = d[ 5] ^ c[ 2] ^ c[13];
  newcrc[11]   = d[ 6] ^ c[ 3] ^ c[14];
  newcrc[12]   = d[ 7] ^ d[ 4] ^ d[ 0] ^ c[ 4] ^ c[ 8] ^ c[12] ^ c[15];
  newcrc[13]   = d[ 5] ^ d[ 1] ^ c[ 5] ^ c[ 9] ^ c[13];
  newcrc[14]   = d[ 6] ^ d[ 2] ^ c[ 6] ^ c[10] ^ c[14];
  newcrc[15]   = d[ 7] ^ d[ 3] ^ c[ 7] ^ c[11] ^ c[15];
  nextCRC16_D8 = newcrc;
end
endfunction


endmodule

